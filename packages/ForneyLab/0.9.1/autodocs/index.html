<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings ¬∑ ForneyLab.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ForneyLab.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Readme</a></li><li class="current"><a class="toctext" href>Docstrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Docstrings</a></li></ul></nav><hr/><div id="topbar"><span>Docstrings</span><a class="fa fa-bars" href="#"></a></div></header><pre><code class="language-none">ForneyLab.*</code></pre><pre><code class="language-none">ForneyLab.+</code></pre><pre><code class="language-none">ForneyLab.==</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@RV" href="#ForneyLab.@RV"><code>ForneyLab.@RV</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@RV provides a convenient way to add Variables and FactorNodes to the graph.</p><p>Examples:</p><pre><code class="language-none"># Automatically create new Variable x, try to assign x.id = :x if this id is available
@RV x ~ GaussianMeanVariance(constant(0.0), constant(1.0))

# Explicitly specify the id of the Variable
@RV [id=:my_y] y ~ GaussianMeanVariance(constant(0.0), constant(1.0))

# Automatically assign z.id = :z if this id is not yet taken
@RV z = x + y

# Manual assignment
@RV [id=:my_u] u = x + y

# Just create a variable
@RV x
@RV [id=:my_x] x</code></pre></div></div></section><pre><code class="language-none">ForneyLab.@composite</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@ensureVariables" href="#ForneyLab.@ensureVariables"><code>ForneyLab.@ensureVariables</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@ensureVariables(...) casts all non-Variable arguments to Variable through constant(arg).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@expectationPropagationRule" href="#ForneyLab.@expectationPropagationRule"><code>ForneyLab.@expectationPropagationRule</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@expectationPropagationRule registers a expectation propagation update  rule by defining the rule type and the corresponding methods for the outboundType  and isApplicable functions. If no name (type) for the new rule is passed, a  unique name (type) will be generated. Returns the rule type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@marginalRule" href="#ForneyLab.@marginalRule"><code>ForneyLab.@marginalRule</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@marginalRule registers a marginal update rule for a (joint) marginal by defining the rule type and the corresponding methods for the isApplicable functions. If no name (type) for the new rule is passed, a unique name (type) will be generated. Returns the rule type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@naiveVariationalRule" href="#ForneyLab.@naiveVariationalRule"><code>ForneyLab.@naiveVariationalRule</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@naiveVariationalRule registers a variational update rule for the naive (mean-field) factorization by defining the rule type and the corresponding methods for the  outboundType and isApplicable functions. If no name (type) for the new rule is passed, a unique name (type) will be generated. Returns the rule type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@structuredVariationalRule" href="#ForneyLab.@structuredVariationalRule"><code>ForneyLab.@structuredVariationalRule</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@structuredVariationalRule registers a variational update rule for the structured factorization by defining the rule type and the corresponding methods for the  outboundType and isApplicable functions. If no name (type) for the new rule is passed, a unique name (type) will be generated. Returns the rule type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@sumProductRule" href="#ForneyLab.@sumProductRule"><code>ForneyLab.@sumProductRule</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>@sumProductRule registers a sum-product update rule by defining the rule type and the corresponding methods for the outboundType and isApplicable functions. If no name (type) for the new rule is passed, a unique name (type) will be generated. Returns the rule type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.@symmetrical" href="#ForneyLab.@symmetrical"><code>ForneyLab.@symmetrical</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><p>Duplicate a method definition with the order of the first two arguments swapped. This macro is used to duplicate methods that are symmetrical in their first two input arguments, but require explicit definitions for the different argument orders. Example:</p><pre><code class="language-none">@symmetrical function prod!(x, y, z)
    ...
end</code></pre></div></div></section><pre><code class="language-none">ForneyLab.AbstractCluster</code></pre><pre><code class="language-none">ForneyLab.AbstractEdge</code></pre><pre><code class="language-none">ForneyLab.AbstractVariable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Addition" href="#ForneyLab.Addition"><code>ForneyLab.Addition</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">An addition constraint factor node

f(out,in1,in2) = Œ¥(in1 + in2 - out)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. in2</code></pre><p>Construction:</p><pre><code class="language-none">Addition(out, in1, in2, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Bernoulli" href="#ForneyLab.Bernoulli"><code>ForneyLab.Bernoulli</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Bernoulli factor node</p><pre><code class="language-none">out ‚àà {0, 1}
p ‚àà [0, 1]

f(out, p) = Ber(out|p) = p^out (1 - p)^{1 - out}</code></pre><p>Interfaces:     1. out     2. p</p><p>Construction:     Bernoulli(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Beta" href="#ForneyLab.Beta"><code>ForneyLab.Beta</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Beta factor node</p><pre><code class="language-none">Real scalars
a &gt; 0
b &gt; 0

f(out, a, b) = Beta(out|a, b) = Œì(a + b)/(Œì(a) Œì(b)) out^{a - 1} (1 - out)^{b - 1}</code></pre><p>Interfaces:     1. out     2. a     3. b</p><p>Construction:     Beta(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Categorical" href="#ForneyLab.Categorical"><code>ForneyLab.Categorical</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Categorical factor node</p><pre><code class="language-none">The categorical node defines a one-dimensional probability
distribution over the normal basis vectors of dimension d

out ‚àà {0, 1}^d where Œ£_k out_k = 1
p ‚àà [0, 1]^d, where Œ£_k p_k = 1

f(out, p) = Cat(out | p)
          = Œ†_i p_i^{out_i}</code></pre><p>Interfaces:     1. out     2. p</p><p>Construction:     Categorical(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Clamp" href="#ForneyLab.Clamp"><code>ForneyLab.Clamp</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A factor that clamps a variable to a constant value.

f(out) = Œ¥(out - value)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out</code></pre><p>Construction:</p><pre><code class="language-none">Clamp(out, value, id=:some_id)
Clamp(value, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Cluster" href="#ForneyLab.Cluster"><code>ForneyLab.Cluster</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A Cluster specifies a collection of <code>edges</code> adjacent to <code>node</code> that belong to the same RecognitionFactor. A joint marginal can be computed over a cluster.</p></div></div></section><pre><code class="language-none">ForneyLab.CompositeNode</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Contingency" href="#ForneyLab.Contingency"><code>ForneyLab.Contingency</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Contingency factor node</p><pre><code class="language-none">The contingency distribution is a multivariate generalization of
the categorical distribution. As a bivariate distribution, the
contingency distribution defines the joint probability
over two unit vectors. The parameter p encodes a contingency matrix
that specifies the probability of co-occurrence.

out1 ‚àà {0, 1}^d1 where Œ£_j out1_j = 1
out2 ‚àà {0, 1}^d2 where Œ£_k out2_k = 1
p ‚àà [0, 1]^{d1 √ó d2}, where Œ£_jk p_jk = 1

f(out1, out2, p) = Con(out1, out2 | p)
                 = Œ†_jk p_jk^{out1_j * out2_k}

A Contingency distribution over more than two variables requires
higher-order tensors as parameters; these are not implemented in ForneyLab.</code></pre><p>Interfaces:     1. out1     2. out2     3. p</p><p>Construction:     Contingency(id=:some_id)</p></div></div></section><pre><code class="language-none">ForneyLab.DeltaFactor</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.DependencyGraph" href="#ForneyLab.DependencyGraph"><code>ForneyLab.DependencyGraph</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>DependencyGraph</code> is a directed graph in which an edge <code>v -&gt; w</code> represents a dependency of vertex <code>v</code> on vertex <code>w</code>. Dependency graphs are used for example by message scheduling algorithms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Dirichlet" href="#ForneyLab.Dirichlet"><code>ForneyLab.Dirichlet</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Dirichlet factor node</p><pre><code class="language-none">Real vector
a .&gt; 0

Multivariate:
f(out, a) = Dir(out|a)
          = Œì(Œ£_i a_i)/(Œ†_i Œì(a_i)) Œ†_i out_i^{a_i}

Matrix variate with independent rows:
f(out, a) = Œ†_j Dir(out|a_j.)
          = Œ†_j Œì(Œ£_k a_jk)/(Œ†_k Œì(a_jk)) Œ†_k out_jk^{a_jk}</code></pre><p>Interfaces:     1. out     2. a</p><p>Construction:     Dirichlet(id=:some_id)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.DotProduct" href="#ForneyLab.DotProduct"><code>ForneyLab.DotProduct</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">out = in1&#39;*in2

in1: d-dimensional vector
in2: d-dimensional vector
out: scalar

       in2
       |
  in1  V   out
-----&gt;[‚ãÖ]-----&gt;

f(out, in1, in2) =  Œ¥(out - in1&#39;*in2)</code></pre><p>Interfaces:</p><pre><code class="language-none">1 i[:out], 2 i[:in1], 3 i[:in2]</code></pre><p>Construction:</p><pre><code class="language-none">DotProduct(out, in1, in2, id=:my_node)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.EPSigmoidRealGB</code></pre><pre><code class="language-none">ForneyLab.EPSigmoidRealGC</code></pre><pre><code class="language-none">ForneyLab.EPSigmoidRealGP</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Edge" href="#ForneyLab.Edge"><code>ForneyLab.Edge</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>An Edge joins two interfaces (half-edges) <code>a</code> and <code>b</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Equality" href="#ForneyLab.Equality"><code>ForneyLab.Equality</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">An equality constraint factor node

f([1],[2],[3]) = Œ¥([1] - [2]) Œ¥([1] - [3])</code></pre><p>Interfaces:</p><pre><code class="language-none">1, 2, 3</code></pre><p>Construction:</p><pre><code class="language-none">Equality(id=:some_id)

The interfaces of an Equality node have to be connected manually.</code></pre></div></div></section><pre><code class="language-none">ForneyLab.ExpectationPropagationRule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Exponential" href="#ForneyLab.Exponential"><code>ForneyLab.Exponential</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Maps a location to a scale parameter by exponentiation

f(out,in1) = Œ¥(out - exp(in1))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1</code></pre><p>Construction:</p><pre><code class="language-none">Exponential(out, in1, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.FactorGraph" href="#ForneyLab.FactorGraph"><code>ForneyLab.FactorGraph</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A factor graph consisting of factor nodes and edges.</p></div></div></section><pre><code class="language-none">ForneyLab.FactorNode</code></pre><pre><code class="language-none">ForneyLab.ForneyLab</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Gamma" href="#ForneyLab.Gamma"><code>ForneyLab.Gamma</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A gamma node with shape-rate parameterization:

f(out,a,b) = Gam(out|a,b) = 1/Œì(a) b^a out^{a - 1} exp(-b out)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. a (shape)
3. b (rate)</code></pre><p>Construction:</p><pre><code class="language-none">Gamma(out, a, b, id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.Gaussian</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMeanPrecision" href="#ForneyLab.GaussianMeanPrecision"><code>ForneyLab.GaussianMeanPrecision</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian with mean-precision parameterization:

f(out,m,w) = ùí©(out|m,w) = (2œÄ)^{-D/2} |w|^{1/2} exp(-1/2 (out - m)&#39; w (out - m))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (mean)
3. w (precision)</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMeanPrecision(out, m, w, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMeanVariance" href="#ForneyLab.GaussianMeanVariance"><code>ForneyLab.GaussianMeanVariance</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian with mean-variance parameterization:

f(out,m,v) = ùí©(out|m,v) = (2œÄ)^{-D/2} |v|^{-1/2} exp(-1/2 (out - m)&#39; v^{-1} (out - m))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (mean)
3. v (covariance)</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMeanVariance(out, m, v, id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.GaussianMixture" href="#ForneyLab.GaussianMixture"><code>ForneyLab.GaussianMixture</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Gaussian mixture with mean-precision parameterization:

f(out, z, m1, w1, m2, w2, ...) = ùí©(out|m1, w1)^z_1 * ùí©(out|m2, w2)^z_2 * ...</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. z (switch)
3. m1 (mean)
4. w1 (precision)
5. m2 (mean)
6. w2 (precision)
...</code></pre><p>Construction:</p><pre><code class="language-none">GaussianMixture(out, z, m1, w1, m2, w2, ..., id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.GaussianWeightedMeanPrecision</code></pre><pre><code class="language-none">ForneyLab.InferenceAlgorithm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Interface" href="#ForneyLab.Interface"><code>ForneyLab.Interface</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>An Interface belongs to a FactorNode and represents a half-edge. An Interface has at most one partner interface, with wich it forms an edge.</p></div></div></section><pre><code class="language-none">ForneyLab.LinkedList</code></pre><pre><code class="language-none">ForneyLab.LinkedListElement</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.LogNormal" href="#ForneyLab.LogNormal"><code>ForneyLab.LogNormal</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A log-normal node with location-scale parameterization:

f(out,m,s) = logN(out|m, s) = 1/out (2œÄ s)^{-1/2} exp(-1/(2s) (log(out) - m)^2))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. m (location)
3. s (squared scale)</code></pre><p>Construction:</p><pre><code class="language-none">LogNormal(out, m, s, id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.MGaussianMeanPrecisionGGD</code></pre><pre><code class="language-none">ForneyLab.MTransitionCCD</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalRule" href="#ForneyLab.MarginalRule"><code>ForneyLab.MarginalRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>MarginalRule{factor<em>type} specifies a joint marginal update rule with respect to a node of type `factor</em>type`.</p></div></div></section><pre><code class="language-none">ForneyLab.MarginalSchedule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalScheduleEntry" href="#ForneyLab.MarginalScheduleEntry"><code>ForneyLab.MarginalScheduleEntry</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>MarginalScheduleEntry</code> defines a marginal computation. The <code>marginal_update_rule &lt;: MarginalUpdateRule</code> defines the rule that is used to calculate the (joint) marginal over <code>target</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MarginalUpdateRule" href="#ForneyLab.MarginalUpdateRule"><code>ForneyLab.MarginalUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A MarginalUpdateRule specifies how a (joint) marginal is calculated from incoming messages (and a node function).</p></div></div></section><pre><code class="language-none">ForneyLab.MatrixVariate</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Message" href="#ForneyLab.Message"><code>ForneyLab.Message</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Encodes a message, which is a probability distribution with a scaling factor</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.MessageUpdateRule" href="#ForneyLab.MessageUpdateRule"><code>ForneyLab.MessageUpdateRule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A MessageUpdateRule specifies how a Message is calculated from the node function and the incoming messages. Use <code>subtypes(MessageUpdateRule)</code> to list the available rules.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Multiplication" href="#ForneyLab.Multiplication"><code>ForneyLab.Multiplication</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">For continuous random variables, the multiplication node acts
as a (matrix) multiplication constraint, with node function

f(out, in1, a) = Œ¥(out - a*in1)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. a</code></pre><p>Construction:</p><pre><code class="language-none">Multiplication(out, in1, a, id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.Multivariate</code></pre><pre><code class="language-none">ForneyLab.NaiveVariationalRule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Nonlinear" href="#ForneyLab.Nonlinear"><code>ForneyLab.Nonlinear</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Nonlinear node modeling a nonlinear relation. Updates for
the nonlinear node are computed through local linearization.

f(out, in1) = Œ¥(out - g(in1))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1</code></pre><p>Construction:</p><pre><code class="language-none">Nonlinear(out, in1, g::Function, J_g::Function, id=:my_node)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.PointMass" href="#ForneyLab.PointMass"><code>ForneyLab.PointMass</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>PointMass is an abstract type used to describe point mass distributions. It never occurs in a FactorGraph, but it is used as a probability distribution type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ProbabilityDistribution" href="#ForneyLab.ProbabilityDistribution"><code>ForneyLab.ProbabilityDistribution</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Encodes a probability distribution as a FactorNode of type <code>family</code> with fixed interfaces</p></div></div></section><pre><code class="language-none">ForneyLab.Product</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.RecognitionFactor" href="#ForneyLab.RecognitionFactor"><code>ForneyLab.RecognitionFactor</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A RecognitionFactor specifies the subset of variables that comprise a joint factor in the recognition factorization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.RecognitionFactorization" href="#ForneyLab.RecognitionFactorization"><code>ForneyLab.RecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A RecognitionFactorization holds a collection of (non-overlapping) recognition factors that specify the recognition factorization over a factor graph that is used for variational inference.</p></div></div></section><pre><code class="language-none">ForneyLab.SPAdditionIn1GVG</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn1GVP</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn1PVG</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn1PVP</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn2GGV</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn2GPV</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn2PGV</code></pre><pre><code class="language-none">ForneyLab.SPAdditionIn2PPV</code></pre><pre><code class="language-none">ForneyLab.SPAdditionOutVGG</code></pre><pre><code class="language-none">ForneyLab.SPAdditionOutVGP</code></pre><pre><code class="language-none">ForneyLab.SPAdditionOutVPG</code></pre><pre><code class="language-none">ForneyLab.SPAdditionOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPBernoulliOutVP</code></pre><pre><code class="language-none">ForneyLab.SPBetaOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPCategoricalOutVP</code></pre><pre><code class="language-none">ForneyLab.SPClamp</code></pre><pre><code class="language-none">ForneyLab.SPDirichletOutVP</code></pre><pre><code class="language-none">ForneyLab.SPDotProductIn1GVP</code></pre><pre><code class="language-none">ForneyLab.SPDotProductIn2GPV</code></pre><pre><code class="language-none">ForneyLab.SPDotProductOutVGP</code></pre><pre><code class="language-none">ForneyLab.SPDotProductOutVPG</code></pre><pre><code class="language-none">ForneyLab.SPEqualityBernoulli</code></pre><pre><code class="language-none">ForneyLab.SPEqualityBeta</code></pre><pre><code class="language-none">ForneyLab.SPEqualityCategorical</code></pre><pre><code class="language-none">ForneyLab.SPEqualityDirichlet</code></pre><pre><code class="language-none">ForneyLab.SPEqualityGammaWishart</code></pre><pre><code class="language-none">ForneyLab.SPEqualityGaussian</code></pre><pre><code class="language-none">ForneyLab.SPEqualityPointMass</code></pre><pre><code class="language-none">ForneyLab.SPExponentialIn1LV</code></pre><pre><code class="language-none">ForneyLab.SPExponentialIn1PV</code></pre><pre><code class="language-none">ForneyLab.SPExponentialOutVG</code></pre><pre><code class="language-none">ForneyLab.SPExponentialOutVP</code></pre><pre><code class="language-none">ForneyLab.SPGammaOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanPrecisionMGVP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanPrecisionMPVP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanPrecisionOutVGP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanPrecisionOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanVarianceMGVP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanVarianceMPVP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanVarianceOutVGP</code></pre><pre><code class="language-none">ForneyLab.SPGaussianMeanVarianceOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPLogNormalOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationAGPV</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationAPPV</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationIn1GVP</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationIn1PVP</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationOutVGP</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationOutVPG</code></pre><pre><code class="language-none">ForneyLab.SPMultiplicationOutVPP</code></pre><pre><code class="language-none">ForneyLab.SPNonlinearIn1GV</code></pre><pre><code class="language-none">ForneyLab.SPNonlinearOutVG</code></pre><pre><code class="language-none">ForneyLab.SPSigmoidBinVG</code></pre><pre><code class="language-none">ForneyLab.SPTransitionIn1CVP</code></pre><pre><code class="language-none">ForneyLab.SPTransitionOutVCP</code></pre><pre><code class="language-none">ForneyLab.SPWishartOutVPP</code></pre><pre><code class="language-none">ForneyLab.SVBGaussianMeanPrecisionMGVD</code></pre><pre><code class="language-none">ForneyLab.SVBGaussianMeanPrecisionOutVGD</code></pre><pre><code class="language-none">ForneyLab.SVBGaussianMeanPrecisionW</code></pre><pre><code class="language-none">ForneyLab.SVBTransitionADV</code></pre><pre><code class="language-none">ForneyLab.SVBTransitionIn1CVD</code></pre><pre><code class="language-none">ForneyLab.SVBTransitionOutVCD</code></pre><pre><code class="language-none">ForneyLab.Schedule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ScheduleEntry" href="#ForneyLab.ScheduleEntry"><code>ForneyLab.ScheduleEntry</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ScheduleEntry</code> defines a message computation. The <code>msg_update_rule &lt;: MessageUpdateRule</code> defines the rule that is used to calculate the message coming out of <code>interface</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Sigmoid" href="#ForneyLab.Sigmoid"><code>ForneyLab.Sigmoid</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:     Constrains a continuous, real-valued variable with a binary (boolean) variable.</p><pre><code class="language-none">f(bin, real) = œÉ(bin‚ãÖreal)</code></pre><p>Interfaces:     1. bin     2. real</p><p>Construction:     Sigmoid(id=:some_id)</p></div></div></section><pre><code class="language-none">ForneyLab.SoftFactor</code></pre><pre><code class="language-none">ForneyLab.StructuredVariationalRule</code></pre><pre><code class="language-none">ForneyLab.SumProductRule</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Terminal" href="#ForneyLab.Terminal"><code>ForneyLab.Terminal</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">Terminal is a special type of node that is only used in the internal
graph of a CompositeNode. A Terminal is used to terminate an Edge in the
internal graph that is linked to an interface of the CompositeNode.

A Terminal is linked to an interface of the
CompositeNode containing the Terminal.</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out</code></pre><p>Construction:</p><pre><code class="language-none">Terminal(id=:some_id)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Transition" href="#ForneyLab.Transition"><code>ForneyLab.Transition</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">The transition node models a transition between discrete
random variables, with node function

f(out, in1, a) = Cat(out | a*in1)</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. in1
3. a</code></pre><p>Construction:</p><pre><code class="language-none">Transition(out, in1, a, id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.Univariate</code></pre><pre><code class="language-none">ForneyLab.VBBernoulliIn1</code></pre><pre><code class="language-none">ForneyLab.VBBernoulliOut</code></pre><pre><code class="language-none">ForneyLab.VBBetaOut</code></pre><pre><code class="language-none">ForneyLab.VBCategoricalIn1</code></pre><pre><code class="language-none">ForneyLab.VBCategoricalOut</code></pre><pre><code class="language-none">ForneyLab.VBDirichletOut</code></pre><pre><code class="language-none">ForneyLab.VBGammaOut</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMeanPrecisionM</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMeanPrecisionOut</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMeanPrecisionW</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMeanVarianceM</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMeanVarianceOut</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMixtureM</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMixtureOut</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMixtureW</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMixtureZBer</code></pre><pre><code class="language-none">ForneyLab.VBGaussianMixtureZCat</code></pre><pre><code class="language-none">ForneyLab.VBLogNormalOut</code></pre><pre><code class="language-none">ForneyLab.VBTransitionA</code></pre><pre><code class="language-none">ForneyLab.VBTransitionIn1</code></pre><pre><code class="language-none">ForneyLab.VBTransitionOut</code></pre><pre><code class="language-none">ForneyLab.VBWishartOut</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Variable" href="#ForneyLab.Variable"><code>ForneyLab.Variable</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>A Variable encompasses one or more edges in a FactorGraph.</p></div></div></section><pre><code class="language-none">ForneyLab.VariateType</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.Wishart" href="#ForneyLab.Wishart"><code>ForneyLab.Wishart</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Description:</p><pre><code class="language-none">A Wishart node:

f(out,v,nu) = W(out|v, nu) = B(v, nu) |out|^{(nu - D - 1)/2} exp(-1/2 tr(v^{-1} out))</code></pre><p>Interfaces:</p><pre><code class="language-none">1. out
2. v (scale matrix)
3. nu (degrees of freedom)</code></pre><p>Construction:</p><pre><code class="language-none">Wishart(out, v, nu, id=:some_id)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.^</code></pre><pre><code class="language-none">ForneyLab.addEdge!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.addNode!" href="#ForneyLab.addNode!"><code>ForneyLab.addNode!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Add a FactorNode to a FactorGraph</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.addVariable!" href="#ForneyLab.addVariable!"><code>ForneyLab.addVariable!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Add a Variable to a FactorGraph</p></div></div></section><pre><code class="language-none">ForneyLab.addVertex!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.approximate" href="#ForneyLab.approximate"><code>ForneyLab.approximate</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Find a local linear approximation to the nonlinear vector function g at x_hat</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.associate!" href="#ForneyLab.associate!"><code>ForneyLab.associate!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>associate!(interface, variable)</code> associates <code>interface</code> with <code>variable</code> by connecting <code>interface</code> to an <code>Edge</code> belonging to <code>variable</code>.</p></div></div></section><pre><code class="language-none">ForneyLab.averageEnergy</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.breakerTypes" href="#ForneyLab.breakerTypes"><code>ForneyLab.breakerTypes</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Constructs breaker types dictionary for breaker sites</p></div></div></section><pre><code class="language-none">ForneyLab.children</code></pre><pre><code class="language-none">ForneyLab.cholinv</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.clusterId" href="#ForneyLab.clusterId"><code>ForneyLab.clusterId</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return the id of the cluster/variable that the node-edge combination belongs to </p></div></div></section><pre><code class="language-none">ForneyLab.collectAverageEnergyInbounds</code></pre><pre><code class="language-none">ForneyLab.collectConditionalDifferentialEntropyInbounds</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectEPSites" href="#ForneyLab.collectEPSites"><code>ForneyLab.collectEPSites</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Find default EP sites present in <code>node_set</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInboundTypes" href="#ForneyLab.collectInboundTypes"><code>ForneyLab.collectInboundTypes</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Find the inbound types that are required to compute a joint marginal over <code>target</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectInbounds" href="#ForneyLab.collectInbounds"><code>ForneyLab.collectInbounds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Construct the inbound code that computes the marginal for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div><div><div><p>Collect and construct SP update code for each inbound.</p></div></div><div><div><p>Construct argument code for naive VB updates</p></div></div><div><div><p>Construct argument code for structured VB updates</p></div></div><div><div><p>Find the inbound types that are required to compute the message for <code>entry</code>. Returns a vector with inbound types that correspond with required interfaces.</p></div></div></section><pre><code class="language-none">ForneyLab.collectMarginalNodeInbounds</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectNaiveVariationalNodeInbounds" href="#ForneyLab.collectNaiveVariationalNodeInbounds"><code>ForneyLab.collectNaiveVariationalNodeInbounds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectStructuredVariationalNodeInbounds" href="#ForneyLab.collectStructuredVariationalNodeInbounds"><code>ForneyLab.collectStructuredVariationalNodeInbounds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.collectSumProductNodeInbounds" href="#ForneyLab.collectSumProductNodeInbounds"><code>ForneyLab.collectSumProductNodeInbounds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Construct the inbound code that computes the message for <code>entry</code>. Allows for overloading and for a user the define custom node-specific inbounds collection. Returns a vector with inbounds that correspond with required interfaces.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.condense" href="#ForneyLab.condense"><code>ForneyLab.condense</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Contruct a condensed schedule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.conditionalDifferentialEntropy" href="#ForneyLab.conditionalDifferentialEntropy"><code>ForneyLab.conditionalDifferentialEntropy</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Compute conditional differential entropy: H(Y|X) = H(Y, X) - H(X)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.connect!" href="#ForneyLab.connect!"><code>ForneyLab.connect!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Connect loose end of edge to interface b.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.constant" href="#ForneyLab.constant"><code>ForneyLab.constant</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>constant</code> creates a <code>Variable</code> which is linked to a new <code>Clamp</code>, and returns this variable.</p><pre><code class="language-none">y = constant(3.0, id=:y)</code></pre></div></div></section><pre><code class="language-none">ForneyLab.convert</code></pre><pre><code class="language-none">ForneyLab.cov</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.currentGraph" href="#ForneyLab.currentGraph"><code>ForneyLab.currentGraph</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return currently active FactorGraph. Create one if there is none.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.currentRecognitionFactorization" href="#ForneyLab.currentRecognitionFactorization"><code>ForneyLab.currentRecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return currently active RecognitionFactorization. Create one if there is none.</p></div></div></section><pre><code class="language-none">ForneyLab.current_graph</code></pre><pre><code class="language-none">ForneyLab.current_recognition_factorization</code></pre><pre><code class="language-none">ForneyLab.diageye</code></pre><pre><code class="language-none">ForneyLab.differentialEntropy</code></pre><pre><code class="language-none">ForneyLab.dims</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.disconnect!" href="#ForneyLab.disconnect!"><code>ForneyLab.disconnect!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Disconnect edge from interface.</p></div></div></section><pre><code class="language-none">ForneyLab.dot</code></pre><pre><code class="language-none">ForneyLab.dot2gif</code></pre><pre><code class="language-none">ForneyLab.dot2pdf</code></pre><pre><code class="language-none">ForneyLab.dot2png</code></pre><pre><code class="language-none">ForneyLab.dot2svg</code></pre><pre><code class="language-none">ForneyLab.draw</code></pre><pre><code class="language-none">ForneyLab.drawPdf</code></pre><pre><code class="language-none">ForneyLab.drawPng</code></pre><pre><code class="language-none">ForneyLab.edgeDot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.edges" href="#ForneyLab.edges"><code>ForneyLab.edges</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Collect all edges corresponding with variable(s)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ensureMatrix" href="#ForneyLab.ensureMatrix"><code>ForneyLab.ensureMatrix</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>ensureMatrix: cast input to a Matrix if necessary</p></div></div></section><pre><code class="language-none">ForneyLab.equal</code></pre><pre><code class="language-none">ForneyLab.eval</code></pre><pre><code class="language-none">ForneyLab.exp</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.expectationPropagationAlgorithm" href="#ForneyLab.expectationPropagationAlgorithm"><code>ForneyLab.expectationPropagationAlgorithm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Create a sum-product algorithm to infer marginals over <code>variables</code>, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.expectationPropagationSchedule" href="#ForneyLab.expectationPropagationSchedule"><code>ForneyLab.expectationPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>expectationPropagationSchedule() generates a expectation propagation message passing schedule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.extend" href="#ForneyLab.extend"><code>ForneyLab.extend</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Find the smallest legal subgraph that includes the argument edges. Default setting terminates the search at soft factors and does not constrain the search to a limiting set (as specified by an empty limit_set argument).</p></div></div></section><pre><code class="language-none">ForneyLab.eye</code></pre><pre><code class="language-none">ForneyLab.family</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.find_vertex_indexes" href="#ForneyLab.find_vertex_indexes"><code>ForneyLab.find_vertex_indexes</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>children(vertices, graph; allow<em>cycles=false, breaker</em>sites=[], restrict_to=[])</p><p>Return a vector consisting of <code>vertices</code> and all their children in <code>graph</code>. <code>v</code> is a child of <code>u</code> iff there exists a path from <code>u</code> to <code>v</code>. The resulting array is sorted in reverse topological order, i.e. for each directed edge <code>u -&gt; v</code>, <code>v</code> (child of <code>u</code>) appears before <code>u</code>.</p><p>Optional keyword arguments:</p><ul><li><code>allow_cycles</code>: set to true to accept cycles.</li><li><code>breaker_sites</code>: a Set of vertices on which the search will terminate.</li><li><code>restrict_to</code>: a Set of vertices to restrict the search to.</li></ul><p>This function can be used to generate message passing schedules if <code>graph</code> is a dependency graph.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.flatten" href="#ForneyLab.flatten"><code>ForneyLab.flatten</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Flatten a schedule by inlining all internal message passing schedules. This yields a simple, linear schedule.</p></div></div></section><pre><code class="language-none">ForneyLab.format</code></pre><pre><code class="language-none">ForneyLab.freeEnergyAlgorithm</code></pre><pre><code class="language-none">ForneyLab.gaussianQuadrature</code></pre><pre><code class="language-none">ForneyLab.genDot</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.generateId" href="#ForneyLab.generateId"><code>ForneyLab.generateId</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Automatically generate a unique id based on the current counter value for the element type.</p></div></div></section><pre><code class="language-none">ForneyLab.graphviz</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.handle" href="#ForneyLab.handle"><code>ForneyLab.handle</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return interface handle name</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasCollider" href="#ForneyLab.hasCollider"><code>ForneyLab.hasCollider</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return whether the subgraph contains a collider. If a collider is found, this will lead to conditional dependencies in the recognition distribution (posterior).</p></div></div><div><div><p>Return whether connected<em>cluster contains a collider. This function assumes the graph for connected</em>cluster is a connected tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasNode" href="#ForneyLab.hasNode"><code>ForneyLab.hasNode</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>hasNode(graph, node)</code> checks if <code>node</code> is part of <code>graph</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.hasVariable" href="#ForneyLab.hasVariable"><code>ForneyLab.hasVariable</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>hasVariable(graph, var)</code> checks if <code>var</code> is part of <code>graph</code>.</p></div></div></section><pre><code class="language-none">ForneyLab.huge</code></pre><pre><code class="language-none">ForneyLab.include</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferMarginalRule" href="#ForneyLab.inferMarginalRule"><code>ForneyLab.inferMarginalRule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Infer the rule that computes the joint marginal over <code>cluster</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferUpdateRule!" href="#ForneyLab.inferUpdateRule!"><code>ForneyLab.inferUpdateRule!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Infer the update rule that computes the message for <code>entry</code>, as dependent on the inbound types</p></div></div><div><div><p>Infer the update rule that computes the message for <code>entry</code>, as dependent on the inbound types</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.inferUpdateRules!" href="#ForneyLab.inferUpdateRules!"><code>ForneyLab.inferUpdateRules!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>inferUpdateRules!(schedule) infers specific message update rules for all schedule entries.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.interfaceToScheduleEntryIdx" href="#ForneyLab.interfaceToScheduleEntryIdx"><code>ForneyLab.interfaceToScheduleEntryIdx</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Generate a mapping from interface to schedule entry index. Multiple interfaces can map to the same schedule entry if the graph contains composite nodes.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.internalSumProductSchedule" href="#ForneyLab.internalSumProductSchedule"><code>ForneyLab.internalSumProductSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>internalSumProductSchedule() generates a sum-product message passing schedule for the inner graph of a CompositeNode. This schedule produces the sum-product message out of the specified outbound_interface.</p></div></div></section><pre><code class="language-none">ForneyLab.invalidate!</code></pre><pre><code class="language-none">ForneyLab.isApplicable</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isApproxEqual" href="#ForneyLab.isApproxEqual"><code>ForneyLab.isApproxEqual</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>isApproxEqual: check approximate equality</p></div></div></section><pre><code class="language-none">ForneyLab.isProper</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isRoundedPosDef" href="#ForneyLab.isRoundedPosDef"><code>ForneyLab.isRoundedPosDef</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>isRoundedPosDef: is input matrix positive definite? Round to prevent fp precision problems that isposdef() suffers from.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.isValid" href="#ForneyLab.isValid"><code>ForneyLab.isValid</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>isValid: return true if the parameter field exists and (the first element of) the parameter is not NaN</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.laplace" href="#ForneyLab.laplace"><code>ForneyLab.laplace</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Gamma approximation to the log-normal distribution using Laplace&#39;s method</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.leaftypes" href="#ForneyLab.leaftypes"><code>ForneyLab.leaftypes</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>leaftypes(datatype)</code> returns all subtypes of <code>datatype</code> that are leafs in the type tree.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localClusterIds" href="#ForneyLab.localClusterIds"><code>ForneyLab.localClusterIds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return the ids of the clusters/variables to which edges connected to <code>node</code> belong</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localRecognitionFactorIds" href="#ForneyLab.localRecognitionFactorIds"><code>ForneyLab.localRecognitionFactorIds</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return the ids of the recognition factors to which edges connected to <code>node</code> belong</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.localRecognitionFactorization" href="#ForneyLab.localRecognitionFactorization"><code>ForneyLab.localRecognitionFactorization</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return a dictionary from recognition factor-id to variable/cluster-ids local to node</p></div></div></section><pre><code class="language-none">ForneyLab.logMomentMatching</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.mapToBernoulliParameterRange" href="#ForneyLab.mapToBernoulliParameterRange"><code>ForneyLab.mapToBernoulliParameterRange</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Map <code>m</code> to range of Bernoulli parameter <code>p</code> ‚àà [0, 1]</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.marginalSchedule" href="#ForneyLab.marginalSchedule"><code>ForneyLab.marginalSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>marginalSchedule() generates a marginal schedule that computes the marginals for each target entry</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.marginalString" href="#ForneyLab.marginalString"><code>ForneyLab.marginalString</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Depending on the origin of the Clamp node message, contruct the marginal code.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.mat" href="#ForneyLab.mat"><code>ForneyLab.mat</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Helper function to construct 1x1 Matrix</p></div></div></section><pre><code class="language-none">ForneyLab.matchPVInputs</code></pre><pre><code class="language-none">ForneyLab.matchPermutedCanonical</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.matches" href="#ForneyLab.matches"><code>ForneyLab.matches</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Special inheritance rules for parametric Message types</p></div></div></section><pre><code class="language-none">ForneyLab.mean</code></pre><pre><code class="language-none">ForneyLab.messagePassingAlgorithm</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.messageString" href="#ForneyLab.messageString"><code>ForneyLab.messageString</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Depending on the origin of the Clamp node message, contruct the outbound message code.</p></div></div></section><pre><code class="language-none">ForneyLab.mode</code></pre><pre><code class="language-none">ForneyLab.momentMatching</code></pre><pre><code class="language-none">ForneyLab.name</code></pre><pre><code class="language-none">ForneyLab.neighbors</code></pre><pre><code class="language-none">ForneyLab.nodes</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.nodesConnectedToExternalEdges" href="#ForneyLab.nodesConnectedToExternalEdges"><code>ForneyLab.nodesConnectedToExternalEdges</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Find the nodes in <code>recognition_factor</code> that are connected to external edges</p></div></div><div><div><p>Find the nodes connected to <code>internal_edges</code> that are also connected to external edges</p></div></div></section><pre><code class="language-none">ForneyLab.outboundType</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.pack" href="#ForneyLab.pack"><code>ForneyLab.pack</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>This function ensures the argument expression is evaluated at runtime, allowing access to local variables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.placeholder" href="#ForneyLab.placeholder"><code>ForneyLab.placeholder</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>placeholder(...)</code> creates a <code>Clamp</code> node and registers this node as a data placeholder with the current graph.</p><pre><code class="language-none"># Link variable y to buffer with id :y,
# indicate that Clamp will hold Float64 values.
placeholder(y, :y, datatype=Float64)

# Link variable y to index 3 of buffer with id :y.
# Specify the data type by passing a default value for the Clamp.
placeholder(y, :y, index=3, default=0.0)

# Indicate that the Clamp will hold an array of size `dims`,
# with Float64 elements.
placeholder(X, :X, datatype=Float64, dims=(3,2))</code></pre></div></div></section><pre><code class="language-none">ForneyLab.prod!</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.recognitionFactorId" href="#ForneyLab.recognitionFactorId"><code>ForneyLab.recognitionFactorId</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Return the id of the RecognitionFactor that <code>edge</code> belongs to</p></div></div></section><pre><code class="language-none">ForneyLab.ruleEPSigmoidRealGB</code></pre><pre><code class="language-none">ForneyLab.ruleEPSigmoidRealGC</code></pre><pre><code class="language-none">ForneyLab.ruleEPSigmoidRealGP</code></pre><pre><code class="language-none">ForneyLab.ruleMGaussianMeanPrecisionGGD</code></pre><pre><code class="language-none">ForneyLab.ruleMTransitionCCD</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn1GVG</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn1GVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn1PVG</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn1PVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn2GGV</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn2GPV</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn2PGV</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionIn2PPV</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionOutVGG</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionOutVGP</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionOutVPG</code></pre><pre><code class="language-none">ForneyLab.ruleSPAdditionOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPBernoulliOutVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPBetaOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPCategoricalOutVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPDirichletOutVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPDotProductIn1GVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPDotProductIn2GPV</code></pre><pre><code class="language-none">ForneyLab.ruleSPDotProductOutVGP</code></pre><pre><code class="language-none">ForneyLab.ruleSPDotProductOutVPG</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityBernoulli</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityBeta</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityCategorical</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityDirichlet</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityGammaWishart</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityGaussian</code></pre><pre><code class="language-none">ForneyLab.ruleSPEqualityPointMass</code></pre><pre><code class="language-none">ForneyLab.ruleSPExponentialIn1LV</code></pre><pre><code class="language-none">ForneyLab.ruleSPExponentialIn1PV</code></pre><pre><code class="language-none">ForneyLab.ruleSPExponentialOutVG</code></pre><pre><code class="language-none">ForneyLab.ruleSPExponentialOutVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGammaOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanPrecisionMGVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanPrecisionMPVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanPrecisionOutVGP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanPrecisionOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanVarianceMGVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanVarianceMPVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanVarianceOutVGP</code></pre><pre><code class="language-none">ForneyLab.ruleSPGaussianMeanVarianceOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPLogNormalOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationAGPV</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationAPPV</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationIn1GVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationIn1PVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationOutVGP</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationOutVPG</code></pre><pre><code class="language-none">ForneyLab.ruleSPMultiplicationOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSPNonlinearIn1GV</code></pre><pre><code class="language-none">ForneyLab.ruleSPNonlinearOutVG</code></pre><pre><code class="language-none">ForneyLab.ruleSPSigmoidBinVG</code></pre><pre><code class="language-none">ForneyLab.ruleSPTransitionIn1CVP</code></pre><pre><code class="language-none">ForneyLab.ruleSPTransitionOutVCP</code></pre><pre><code class="language-none">ForneyLab.ruleSPWishartOutVPP</code></pre><pre><code class="language-none">ForneyLab.ruleSVBGaussianMeanPrecisionMGVD</code></pre><pre><code class="language-none">ForneyLab.ruleSVBGaussianMeanPrecisionOutVGD</code></pre><pre><code class="language-none">ForneyLab.ruleSVBGaussianMeanPrecisionW</code></pre><pre><code class="language-none">ForneyLab.ruleSVBTransitionADV</code></pre><pre><code class="language-none">ForneyLab.ruleSVBTransitionIn1CVD</code></pre><pre><code class="language-none">ForneyLab.ruleSVBTransitionOutVCD</code></pre><pre><code class="language-none">ForneyLab.ruleVBBernoulliIn1</code></pre><pre><code class="language-none">ForneyLab.ruleVBBernoulliOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBBetaOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBCategoricalIn1</code></pre><pre><code class="language-none">ForneyLab.ruleVBCategoricalOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBDirichletOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBGammaOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMeanPrecisionM</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMeanPrecisionOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMeanPrecisionW</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMeanVarianceM</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMeanVarianceOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMixtureM</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMixtureOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMixtureW</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMixtureZBer</code></pre><pre><code class="language-none">ForneyLab.ruleVBGaussianMixtureZCat</code></pre><pre><code class="language-none">ForneyLab.ruleVBLogNormalOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBTransitionA</code></pre><pre><code class="language-none">ForneyLab.ruleVBTransitionIn1</code></pre><pre><code class="language-none">ForneyLab.ruleVBTransitionOut</code></pre><pre><code class="language-none">ForneyLab.ruleVBWishartOut</code></pre><pre><code class="language-none">ForneyLab.sample</code></pre><pre><code class="language-none">ForneyLab.setCurrentGraph</code></pre><pre><code class="language-none">ForneyLab.setCurrentRecognitionFactorization</code></pre><pre><code class="language-none">ForneyLab.slug</code></pre><pre><code class="language-none">ForneyLab.softmax</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.sumProductAlgorithm" href="#ForneyLab.sumProductAlgorithm"><code>ForneyLab.sumProductAlgorithm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Create a sum-product algorithm to infer marginals over <code>variables</code>, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.sumProductSchedule" href="#ForneyLab.sumProductSchedule"><code>ForneyLab.sumProductSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>sumProductSchedule() generates a sum-product message passing schedule that computes the marginals for each of the argument variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.summaryDependencyGraph" href="#ForneyLab.summaryDependencyGraph"><code>ForneyLab.summaryDependencyGraph</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>summaryDependencyGraph(edgeset)</p><p>Returns a DependencyGraph (directed graph) that encodes the dependencies among summary messages (such as sum-product messages) in <code>edgeset</code>. All Interfaces in <code>edgeset</code> are vertices in the dependency graph. The dependency graph can be used for loop detection, scheduling, etc.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.summaryPropagationSchedule" href="#ForneyLab.summaryPropagationSchedule"><code>ForneyLab.summaryPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p><code>summaryPropagationSchedule(variables)</code> builds a generic summary propagation <code>Schedule</code> for calculating the marginal distributions of every variable in <code>variables</code>. The message update rule in each schedule entry is set to <code>Nothing</code>.</p></div></div></section><pre><code class="language-none">ForneyLab.swap_arguments</code></pre><pre><code class="language-none">ForneyLab.tiny</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.trigammaInverse" href="#ForneyLab.trigammaInverse"><code>ForneyLab.trigammaInverse</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>trigammaInverse(x): solve <code>trigamma(y) = x</code> for <code>y</code>.</p><p>Uses Newton&#39;s method on the convex function 1/trigramma(y). Iterations converge monotonically. Based on trigammaInverse implementation in R package &quot;limma&quot; by Gordon Smyth: https://github.com/Bioconductor-mirror/limma/blob/master/R/fitFDist.R</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.ultimatePartner" href="#ForneyLab.ultimatePartner"><code>ForneyLab.ultimatePartner</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>ultimatePartner(interface) finds the &#39;ultimate partner&#39; of interface. If interface.partner does not belong to a Terminal, it simply returns interface.partner. In case of a Terminal node, it finds the first non-Terminal partner on a higher level factor graph.</p></div></div></section><pre><code class="language-none">ForneyLab.unsafeCov</code></pre><pre><code class="language-none">ForneyLab.unsafeDetLogMean</code></pre><pre><code class="language-none">ForneyLab.unsafeInverseMean</code></pre><pre><code class="language-none">ForneyLab.unsafeLogCov</code></pre><pre><code class="language-none">ForneyLab.unsafeLogMean</code></pre><pre><code class="language-none">ForneyLab.unsafeLogVar</code></pre><pre><code class="language-none">ForneyLab.unsafeMean</code></pre><pre><code class="language-none">ForneyLab.unsafeMeanCov</code></pre><pre><code class="language-none">ForneyLab.unsafeMeanVector</code></pre><pre><code class="language-none">ForneyLab.unsafeMirroredLogMean</code></pre><pre><code class="language-none">ForneyLab.unsafeMode</code></pre><pre><code class="language-none">ForneyLab.unsafePrecision</code></pre><pre><code class="language-none">ForneyLab.unsafeVar</code></pre><pre><code class="language-none">ForneyLab.unsafeWeightedMean</code></pre><pre><code class="language-none">ForneyLab.unsafeWeightedMeanPrecision</code></pre><pre><code class="language-none">ForneyLab.vague</code></pre><pre><code class="language-none">ForneyLab.validateGraphVizInstalled</code></pre><pre><code class="language-none">ForneyLab.var</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variateType" href="#ForneyLab.variateType"><code>ForneyLab.variateType</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Extract VariateType from dist</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalAlgorithm" href="#ForneyLab.variationalAlgorithm"><code>ForneyLab.variationalAlgorithm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Create a variational algorithm to infer marginals over a recognition distribution, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalExpectationPropagationAlgorithm" href="#ForneyLab.variationalExpectationPropagationAlgorithm"><code>ForneyLab.variationalExpectationPropagationAlgorithm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Create a variational EP algorithm to infer marginals over a recognition distribution, and compile it to Julia code</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalExpectationPropagationSchedule" href="#ForneyLab.variationalExpectationPropagationSchedule"><code>ForneyLab.variationalExpectationPropagationSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>variationalExpectationPropagationSchedule() generates an expectation propagation message passing schedule that is limited to the <code>recognition_factor</code>. Updates on EP sites are computed with an <code>ExpectationPropagationRule</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ForneyLab.variationalSchedule" href="#ForneyLab.variationalSchedule"><code>ForneyLab.variationalSchedule</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>variationalSchedule() generates a variational message passing schedule that computes the marginals for each of the recognition distributions in the recognition factor.</p></div></div></section><pre><code class="language-none">ForneyLab.viewDotExternal</code></pre><pre><code class="language-none">ForneyLab.viewDotExternalImage</code></pre><pre><code class="language-none">ForneyLab.viewDotExternalInteractive</code></pre><pre><code class="language-none">ForneyLab.viewDotIniTerm</code></pre><pre><code class="language-none">ForneyLab.viewFile</code></pre><pre><code class="language-none">ForneyLab.writeInitializationBlock</code></pre><pre><code class="language-none">ForneyLab.writeMarginalsComputationBlock</code></pre><pre><code class="language-none">ForneyLab.writeMessagePassingBlock</code></pre><pre><code class="language-none">ForneyLab.Œ¶</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Readme</span></a></footer></article></body></html>
