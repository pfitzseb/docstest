<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · ImageView.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ImageView.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Preparation-1">Preparation</a></li><li><a class="toctext" href="#Demonstration-of-the-GUI-1">Demonstration of the GUI</a></li><li><a class="toctext" href="#Programmatic-usage-1">Programmatic usage</a></li><li><a class="toctext" href="#Annotations-1">Annotations</a></li><li><a class="toctext" href="#Additional-notes-1">Additional notes</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ImageView.jl-1" href="#ImageView.jl-1">ImageView.jl</a></h1><p>An image display GUI for <a href="http://julialang.org/">Julia</a>.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>To install the <code>ImageView</code> package:</p><pre><code class="language-julia">Pkg.add(&quot;ImageView&quot;)</code></pre><h2><a class="nav-anchor" id="Preparation-1" href="#Preparation-1">Preparation</a></h2><p>First let&#39;s try it with a photograph. If you have an image on your computer, load it this way:</p><pre><code class="language-julia">using ImageView, Images
img = load(&quot;my_photo.jpg&quot;)</code></pre><p>Any typical image format should be fine, it doesn&#39;t have to be a jpg. The <a href="https://github.com/timholy/TestImages.jl"><code>TestImages</code></a> package contains several standard images:</p><pre><code class="language-julia">using TestImages
img = testimage(&quot;mandrill&quot;)</code></pre><h2><a class="nav-anchor" id="Demonstration-of-the-GUI-1" href="#Demonstration-of-the-GUI-1">Demonstration of the GUI</a></h2><p>For simplicity, you should first test ImageView at the REPL prompt or in an IDE; script usage is discussed later below.</p><p>You can view the image using <code>imshow</code>:</p><pre><code class="language-julia">imshow(img)</code></pre><p>You should get a window with your image:</p><p><img src="readme_images/photo1.jpg" alt="photo"/></p><p>You can use <code>imshow()</code> if you want to choose an image using a file dialog.</p><p>Try resizing the image window by dragging one of its corners; you&#39;ll see that the aspect ratio of the image is preserved when you resize. If instead you want the image to fill the pane, try <code>imshow(img, aspect=:none)</code>. Here&#39;s a comparison of the two:</p><table><tr><th>aspect=:auto (default)</th><th>aspect=:none</th></tr><tr><td><img src="readme_images/photo2.jpg" alt="photo"/></td><td><img src="readme_images/photo3.jpg" alt="photo"/></td></tr></table><p>Next, Ctrl-click and drag somewhere inside the image.  You&#39;ll see the typical rubberband selection, and once you let go the image display will zoom in on the selected region.  Again, the aspect ratio of the display is preserved.  If you click on the image without holding down Ctrl, you can drag the image to look at nearby regions. Ctrl-double-click on the image to restore the full region.</p><p>If you have a wheel mouse, zoom in again and scroll the wheel, which should cause the image to pan vertically. If you scroll while holding down Shift, it pans horizontally; hold down Ctrl and you affect the zoom setting. Note as you zoom via the mouse, the zoom stays focused around the mouse pointer location, making it easy to zoom in on some small feature simply by pointing your mouse at it and then Ctrl-scrolling.</p><p>You can view the image upside-down with</p><pre><code class="language-julia">imshow(img, flipy=true)</code></pre><p>(<code>flipx</code> flips the image horizontally) or switch the horizontal and vertical axes with</p><pre><code class="language-julia">imshow(img, axes=(2,1)).</code></pre><p>For movies, 3D, and 4D images, ImageView will create a &quot;player&quot; widget.</p><pre><code class="language-julia">img = testimage(&quot;mri&quot;)
imshow(img)</code></pre><p>The <code>&quot;mri&quot;</code> image is an <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArray</a>, and consequently you can select axes by name:</p><pre><code class="language-julia">imshow(img, axes=(:S, :P), flipy=true)  # a sagittal plane (Superior, Posterior)</code></pre><table><tr><th><code>imshow(img)</code></th><th><code>imshow(img, axes=(:S, :P), flipy=true)</code></th></tr><tr><td><img src="readme_images/mri.jpg" alt="photo"/></td><td><img src="readme_images/mri_sagittal.jpg" alt="photo"/></td></tr></table><p>Finally, for grayscale images, right-clicking on the image yields a brightness/contrast GUI:</p><p><img src="readme_images/contrast.jpg" alt="Contrast GUI snapshot"/></p><p>You can adjust the contrast by adjusting the sliders or by entering values into the text boxes.</p><h2><a class="nav-anchor" id="Programmatic-usage-1" href="#Programmatic-usage-1">Programmatic usage</a></h2><h3><a class="nav-anchor" id="Simple-command-line-utilities-1" href="#Simple-command-line-utilities-1">Simple command-line utilities</a></h3><p><code>ImageView.closeall()</code> closes all open windows.</p><p>You can place multiple images in the same window using <code>canvasgrid</code>:</p><pre><code class="language-none">using ImageView, TestImages, Gtk.ShortNames
grid, frames, canvases = canvasgrid((1,2))  # 1 row, 2 columns
imshow(canvases[1,1], testimage(&quot;lighthouse&quot;))
imshow(canvases[1,2], testimage(&quot;mandrill&quot;))
win = Window(grid)
Gtk.showall(win)</code></pre><p><img src="readme_images/canvasgrid.jpg" alt="canvasgrid snapshot"/></p><h3><a class="nav-anchor" id="The-dictionary-and-region-of-interest-manipulations-1" href="#The-dictionary-and-region-of-interest-manipulations-1">The dictionary and region-of-interest manipulations</a></h3><p><code>imshow</code> returns a dictionary containing a wealth of information about the state of the viewer. Perhaps most interesting is the <code>&quot;roi&quot;</code> entry, which itself is another dictionary containing information about the current selected region or interest. These are <a href="https://juliagizmos.github.io/Reactive.jl/">Reactive signals</a>, and consequently you can even manipulate the state of the GUI by <code>push!</code>ing new values to these signals.</p><p>For example, using the <code>&quot;mri&quot;</code> image above, you can select the 5th slice with</p><pre><code class="language-julia">guidict = imshow(img)
push!(guidict[&quot;roi&quot;][&quot;slicedata&quot;].signals[1], 5)</code></pre><p><code>SliceData</code> objects contain information about which axes are displayed and the current slice indices of those axes perpendicular to the view plane. Likewise, <code>&quot;image roi&quot;</code> contains the actual image data currently being shown in the window (including all zoom/slice settings).</p><p>The <code>&quot;zoom&quot;</code>- and <code>&quot;pan&quot;</code>-related signals originate from <a href="https://juliagizmos.github.io/GtkReactive.jl/stable/">GtkReactive</a>, and users should see the documentation for that package for more information.</p><h3><a class="nav-anchor" id="Coupling-two-or-more-images-together-1" href="#Coupling-two-or-more-images-together-1">Coupling two or more images together</a></h3><p><code>imshow</code> allows you to pass many more arguments; please use <code>?imshow</code> to see some of the options. We can use these extra arguments to couple the zoom and slice regions between two images. Let&#39;s make a &quot;fake&quot; image encoding the segmentation of an image:</p><pre><code class="language-julia">using ImageView, GtkReactive, TestImages, Colors

# Prepare the data
mri = testimage(&quot;mri&quot;)
mriseg = RGB.(mri)
mriseg[mri .&gt; 0.5] = colorant&quot;red&quot;</code></pre><p>Now we display the images:</p><pre><code class="language-julia">guidata = imshow(mri, axes=(1,2))
zr = guidata[&quot;roi&quot;][&quot;zoomregion&quot;]
slicedata = guidata[&quot;roi&quot;][&quot;slicedata&quot;]
imshow(mriseg, nothing, zr, slicedata)</code></pre><p>Here we used <code>imshow</code> to create the first window, and then extracted the <code>zoomregion</code> and <code>slicedata</code> information from that display and used them to intialize a second window with the second image. If you zoom, pan, or change the slice plane in one window, it makes the same change in the other.</p><p>Alternatively, you can place both displays in a single window:</p><pre><code class="language-julia">zr, slicedata = roi(mri, (1,2))
gd = imshow_gui((200, 200), slicedata, (1,2))
imshow(gd[&quot;frame&quot;][1,1], gd[&quot;canvas&quot;][1,1], mri, nothing, zr, slicedata)
imshow(gd[&quot;frame&quot;][1,2], gd[&quot;canvas&quot;][1,2], mriseg, nothing, zr, slicedata)
Gtk.showall(gd[&quot;window&quot;])</code></pre><p>You should see something like this:</p><p><img src="readme_images/coupled.jpg" alt="coupled"/></p><h2><a class="nav-anchor" id="Annotations-1" href="#Annotations-1">Annotations</a></h2><p>You can add and remove various annotations to images (currently text, points, and lines). There are two basic styles of annotation: &quot;anchored&quot; and &quot;floating.&quot; An &quot;anchored&quot; annotation is positioned at a particular pixel location within the image; if you zoom or pan, the annotation will move with the image, and may not even be shown if the corresponding position is off-screen. In contrast, a &quot;floating&quot; annotation is not tied to a particular location in the image, and will always be displayed at approximately the same position within the window even if you zoom or pan. As a consequence, &quot;anchored&quot; annotations are best for labeling particular features in the image, and &quot;floating&quot; annotations are best for things like scalebars.</p><p>Here&#39;s an example of adding a 30-pixel scale bar to an image:</p><pre><code class="language-julia">guidict = imshow(img)
scalebar(guidict, 30; x = 0.1, y = 0.05)</code></pre><p><code>x</code> and <code>y</code> describe the center of the scale bar in normalized coordinates, with <code>(0,0)</code> in the upper left.  In this example, the length of the scale bar is in pixels, but if you&#39;re using the <a href="https://github.com/ajkeller34/Unitful.jl">Unitful</a> package for the image&#39;s <code>pixelspacing</code>, then you should set the length to something like <code>50μm</code>.</p><p>The remaining examples are for fixed annotations. Here is a demonstration:</p><pre><code class="language-julia">using Images, Colors, ImageView
z = ones(10,50);
y = 8; x = 2;
z[y,x] = 0
guidict = imshow(z)
idx = annotate!(guidict, AnnotationText(x, y, &quot;x&quot;, color=RGB(0,0,1), fontsize=3))
idx2 = annotate!(guidict, AnnotationPoint(x+10, y, shape=&#39;.&#39;, size=4, color=RGB(1,0,0)))
idx3 = annotate!(guidict, AnnotationPoint(x+20, y-6, shape=&#39;.&#39;, size=1, color=RGB(1,0,0), linecolor=RGB(0,0,0), scale=true))
idx4 = annotate!(guidict, AnnotationLine(x+10, y, x+20, y-6, linewidth=2, color=RGB(0,1,0)))
idx5 = annotate!(guidict, AnnotationBox(x+10, y, x+20, y-6, linewidth=2, color=RGB(0,0,1)))
delete!(guidict, idx)</code></pre><h4><a class="nav-anchor" id="Annotation-API-1" href="#Annotation-API-1">Annotation API</a></h4><pre><code class="language-none">AnnotationText(x, y, str;
               z = NaN, t =  NaN,
               color = RGB(0,0,0), angle = 0.0, fontfamily = &quot;sans&quot;, fontsize = 10,
               fontoptions = &quot;&quot;,  halign = &quot;center&quot;, valign = &quot;center&quot;, markup = false, scale=true)</code></pre><p>Place <code>str</code> at position <code>(x,y)</code>.</p><p>Properties:</p><ul><li><code>z</code> - position on z axis, for 3D images</li><li><code>t</code> - position on time axis, for movie-like images</li><li><code>color</code></li><li><code>angle</code></li><li><code>fontfamily</code></li><li><code>fontsize</code> - font size in points</li><li><code>fontoptions</code></li><li><code>halign</code> - &quot;center&quot;, &quot;left&quot;, or &quot;right&quot;</li><li><code>valign</code> - &quot;center&quot;, &quot;top&quot;, or &quot;bottom&quot;</li><li><code>markup</code></li><li><code>scale</code> - scale the text as the image is zoomed (default: <code>true</code>)</li></ul><pre><code class="language-none">AnnotationPoints([xy | xys | x, y];
                 z = NaN, t = NaN, size=10.0, shape::Char=&#39;x&#39;,
                 color = RGB(1,1,1), linewidth=1.0, linecolor=color, scale::Bool=false)</code></pre><p>Annotate the point <code>xy</code>, <code>(x,y)</code>, or the points <code>xys</code>.  <code>xys</code> maybe a Vector of tuples <code>Vector{(Real,Real)}</code>, or a <code>2 x N</code> Matrix.  Points are assumed to be in <code>(x,y)</code> order. (TODO: this could be generalized, as with lines.)</p><p>Properties:</p><ul><li><code>z</code> - position on z axis, for 3D images</li><li><code>t</code> - position on time axis, for movie-like images</li><li><code>size</code> - how large to draw the point</li><li><code>shape</code> - one of <code>&#39;.&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;*&#39;</code></li><li><code>color</code></li><li><code>linewidth</code> - width of lines used to draw the point</li><li><code>linecolor</code> - line color; defaults to <code>color</code>; filled circles (shape=<code>&#39;.&#39;</code>) can have a different outline and fill color</li><li><code>scale</code> - scale the drawn size of the point when the image is scaled (default: <code>false</code>)</li></ul><pre><code class="language-none">AnnotationLines(line | lines | c1,c2,c3,c4;
                z = NaN, t = NaN,
                color = RGB(1,1,1), linewidth=1.0, coord_order=&quot;xyxy&quot;)</code></pre><p>Draw <code>line</code>, <code>lines</code>, or the line with coordinates <code>(c1,c2,c3,c4)</code>.  <code>line</code> is specified as a tuple of point tuples, <code>((x1,y1),(x2,y2))</code>.  <code>lines</code> may be a <code>Vector</code> of such lines, or a <code>4 x N</code> matrix.  For a matrix or when specifying coordinates independently, the coordinate order is specified by <code>coord_order</code>, which defaults to &quot;xyxy&quot;.</p><p>Properties:</p><ul><li><code>z</code> - position on z axis, for 3D images</li><li><code>t</code> - position on time axis, for movie-like images</li><li><code>color</code></li><li><code>linewidth</code> - width of the line(s)</li><li><code>coord_order</code> - for matrix or coordinate inputs, the order of the coordinates (e.g., &quot;xyxy&quot;, &quot;xxyy&quot;, &quot;yyxx&quot;)</li></ul><pre><code class="language-none">AnnotationBox(left, top, right, bottom | (x1,y1), (x2,y2) | bb::Graphics.BoundingBox;
              z = NaN, t = NaN,
              color = RGB(1,1,1), linewidth=1.0, coord_order=&quot;xyxy&quot;)</code></pre><p>Draw a box.  Box can be specified using four values for <code>(left, top, right, bottom)</code>, as a pair of tuples, <code>(x1,y1),(x2,y2)</code>, or as a <code>BoundingBox</code>.  The coordinate order the pair of tuples may be specified by <code>coord_order</code>, which defaults to &quot;xyxy&quot;.</p><p>Properties:</p><ul><li><code>z</code> - position on z axis, for 3D images</li><li><code>t</code> - position on time axis, for movie-like images</li><li><code>color</code></li><li><code>linewidth</code> - width of the lines</li></ul><h2><a class="nav-anchor" id="Additional-notes-1" href="#Additional-notes-1">Additional notes</a></h2><h3><a class="nav-anchor" id="Calling-imshow-from-a-script-file-1" href="#Calling-imshow-from-a-script-file-1">Calling imshow from a script file</a></h3><p>If you call Julia from a script file, the julia process will terminate at the end of the program. This will cause any windows opened with <code>imshow()</code> to terminate, which is probably not what you intend. We want to make it only terminate the process when the image window is closed. Below is some example code to do this:</p><pre><code class="language-none">using Images, ImageView, TestImages, Gtk.ShortNames

img = testimage(&quot;mandrill&quot;)
guidict = imshow(img);

#If we are not in a REPL
if (!isinteractive())

    # Create a condition object
    c = Condition()

    # Get the window
    win = guidict[&quot;gui&quot;][&quot;window&quot;]

    # Notify the condition object when the window closes
    signal_connect(win, :destroy) do widget
        notify(c)
    end

    # Wait for the notification before proceeding ...
    wait(c)
end</code></pre><p>This will prevent the julia process from terminating immediately. Note that if we did not call <code>signal_connect</code>, the process will keep waiting even after the image window has closed, and you will have to manually close it with <code>CTRL + C</code>.</p><p>If you are opening more than one window you will need to create more than one <code>Condition</code> object, if you wish to wait until the last one is closed.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
