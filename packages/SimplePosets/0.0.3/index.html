<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · SimplePosets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SimplePosets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Basic-constructor-1">Basic constructor</a></li><li><a class="toctext" href="#Add/delete-elements/relations-1">Add/delete elements/relations</a></li><li><a class="toctext" href="#Basic-inspection-1">Basic inspection</a></li><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Operations-1">Operations</a></li><li><a class="toctext" href="#Poset-properties-1">Poset properties</a></li><li><a class="toctext" href="#Linear-extensions-1">Linear extensions</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="SimplePosets-1" href="#SimplePosets-1">SimplePosets</a></h1><p><a href="https://travis-ci.org/scheinerman/SimplePosets.jl"><img src="https://travis-ci.org/scheinerman/SimplePosets.jl.svg?branch=master" alt="Build Status"/></a></p><p><a href="http://codecov.io/github/scheinerman/SimplePosets.jl?branch=master"><img src="http://codecov.io/github/scheinerman/SimplePosets.jl/coverage.svg?branch=master" alt="codecov.io"/></a></p><p>This module defines a <code>SimplePoset</code> type for Julia. A <em>poset</em> is a pair <code>(X,&lt;)</code> where <code>X</code> is a set of elements and <code>&lt;</code> is a relation on <code>X</code> that is irreflexive, antisymmetric, and transitive.</p><h2><a class="nav-anchor" id="Basic-constructor-1" href="#Basic-constructor-1">Basic constructor</a></h2><p>Use <code>SimplePoset(T)</code> to create a new <code>SimplePoset</code> with elements having type <code>T</code> (which defaults to <code>Any</code>).</p><h2><a class="nav-anchor" id="Add/delete-elements/relations-1" href="#Add/delete-elements/relations-1">Add/delete elements/relations</a></h2><p>Elements and relations can be added to or deleted from a poset using these functions:</p><ul><li><code>add!(P,x)</code> adds a new element <code>x</code> to the ground set of <code>P</code>.</li><li><code>add!(P,x,y)</code> inserts the relation <code>x&lt;y</code> into <code>P</code>. If one (or both) of <code>x</code> and <code>y</code> is not in <code>P</code>, it is added as well.</li><li><code>delete!(P,x)</code> deletes element <code>x</code> from this poset.</li><li><code>delete!(P,x,y)</code> delete the relation <code>x&lt;y</code> from <code>P</code> and for any <code>z</code> with <code>x &lt; z &lt; y</code>, also delete <code>x&lt;z</code> and <code>z&lt;y</code>.</li></ul><p>More detail on element/relation addition/deletion can be found in the document <code>addition-deletion.pdf</code> found in the <code>doc</code> folder.</p><h2><a class="nav-anchor" id="Basic-inspection-1" href="#Basic-inspection-1">Basic inspection</a></h2><ul><li><code>elements(P)</code> returns a list of the elements in <code>P</code></li><li><code>card(P)</code> returns the cardinality of <code>P</code> (number of elements).</li><li><code>relations(P)</code> returns a list of all pairs <code>(x,y)</code> with <code>x&lt;y</code> in this poset.</li><li><code>incomparables(P)</code> returns a list of all incomparable pairs. If <code>(x,y)</code> is listed, we do not also list <code>(y,x)</code>.</li><li><code>has(P,x)</code> determine if <code>x</code> is an element of <code>P</code>.</li><li><code>has(P,x,y)</code> determine if <code>x&lt;y</code> in the poset <code>P</code>. <strong>Note</strong>: Calling <code>has(P,x,x)</code> for an element <code>x</code> of this poset returns <code>false</code>. All our methods concern the strict relation <code>&lt;</code>.</li><li><code>above(P,x)</code> returns a list of all elements above <code>x</code> in <code>P</code>.</li><li><code>below(P,x)</code> returns a list of all elements below <code>x</code> in <code>P</code>.</li><li><code>interval(P,x,y)</code> returns a list of all elements <code>z</code> that satisfy <code>x&lt;z&lt;y</code>.</li><li><code>maximals(P)</code> returns a list of the minimal elements of <code>P</code>.</li><li><code>minimals(P)</code> returns a list of the minimal elements of <code>P</code>.</li></ul><p>The following functions are not likely to be called by the casual user.</p><ul><li><p><code>check(P)</code> returns <code>true</code> provided the internal data structures of <code>P</code> are valid and <code>false</code> otherwise. <strong>Note</strong>: There should be no reason to use this function if the poset is created and manipulated by the functions provided in this module.</p></li><li><p><code>hash(P)</code> computes a hash value for the poset. This enables <code>SimplePoset</code> objects to serve as keys in dictionaries, and so forth.</p></li><li><p><code>element_type(P)</code> returns the datatype of the elements in this poset. For example:</p><pre><code class="language-julia">julia&gt; P = Boolean(3);

julia&gt; element_type(P)
ASCIIString (constructor with 2 methods)</code></pre></li></ul><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><ul><li><code>Antichain(n)</code> creates an antichain with elements <code>1:n</code>. The function <code>IntPoset(n)</code> is a synonym.</li><li><code>Antichain(list)</code> creates an antichain with elements drawn from <code>list</code>, a one-dimensional array.</li><li><code>BooleanLattice(n)</code> creates the subsets of an <code>n</code>-set poset in which elements are named as <code>n</code>-long binary strings.</li><li><code>Chain(n)</code> creates a chain with elements <code>1:n</code> in which <code>1&lt;2&lt;3&lt;...&lt;n</code>.</li><li><code>Chain(list)</code> creates a chain with elements drawn from <code>list</code> (in that order) in.</li><li><code>Divisors(n)</code> creates the poset whose elements are the divisors of <code>n</code> ordered by divisibility.</li><li><code>PartitionLattice(n)</code> creates the poset whose elements are the partitions of</li></ul><p><code>{1,2,...,n}</code> ordered by refinement.</p><ul><li><code>RandomPoset(n,d)</code> creates a random <code>d</code>-dimensional poset on <code>n</code> elements.</li><li><code>StandardExample(n)</code> creates the canonical <code>n</code>-dimensional poset with <code>2n</code> elements in two layers. The lower layer elements are named from <code>-1</code> to <code>-n</code> and the upper layer from <code>1</code> to <code>n</code>. We have <code>-i&lt;j</code> exactly when <code>i!=j</code>.</li></ul><h2><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h2><ul><li><p><code>inv(P)</code> creates the inverse poset of <code>P</code>, i.e., we have <code>x&lt;y</code> in <code>P</code> iff we have <code>y&lt;x</code> in <code>inv(P)</code>. We can use <code>P&#39;</code> as a synonym for <code>inv(P)</code>.</p></li><li><p><code>intersect(P,Q)</code> creates the intersection of the two posets (which must be of the same element type). Typically the two posets have the same elements, but this is not necessary. The resulting poset&#39;s elements is the intersection of the two element sets, and relations in the result are those relations common to both <code>P</code> and <code>Q</code>.</p></li><li><p><code>P*Q</code> is the Cartesian product of the two posets (that may be of different types).</p></li><li><p><code>P+Q</code> is the disjoint union of two (or more) posets. The posets must all be of the same type. Each summand&#39;s elements is extended with an integer (starting at 1) corresponding to its position in the sum. That is, if <code>x</code> is an element of summand number <code>i</code>, then in the sum it becomes the element <code>(x,i)</code>. For example:</p><pre><code class="language-julia">julia&gt; P = Chain(2)+Chain(3)+Chain(4)
SimplePoset{(Int64,Int64)} (9 elements)

julia&gt; elements(P)
9-element Array{(Int64,Int64),1}:
 (1,1)
 (1,2)
 (1,3)
 (2,1)
 (2,2)
 (2,3)
 (3,2)
 (3,3)
 (4,3)</code></pre></li><li><p><code>stack(Plist...)</code> creates a new poset from the ones in the argument list by stacking one atop the next. The first poset in the list is at the bottom.  Element labeling is as in <code>+</code>.</p></li><li><p><code>relabel(P,labels)</code> is used to create a new poset in which the elements  have new names (as given by the dictionary <code>labels</code>). Calling  <code>relabel(P)</code> gives a new poset in which the new element names are  the integers <code>1</code> through <code>n</code>. Here&#39;s an example:</p><p>```julia  julia&gt; P = Chain(3) + Chain(3)  SimplePoset{(Int64,Int64)} (6 elements)</p><p>julia&gt; elements(P)  6-element Array{(Int64,Int64),1}:   (1,1)   (1,2)   (2,1)   (2,2)   (3,1)   (3,2)</p><p>julia&gt; Q = relabel(P)  SimplePoset{Int64} (6 elements)</p><p>julia&gt; elements(Q)  6-element Array{Int64,1}:   1   2   3   4   5   6  ```</p></li></ul><h2><a class="nav-anchor" id="Poset-properties-1" href="#Poset-properties-1">Poset properties</a></h2><ul><li><code>ComparabilityGraph(P)</code> returns a <code>SimpleGraph</code> whose vertices are the elements of <code>P</code> and in which two distinct vertices are adjacent iff they are comparable in <code>P</code>.</li><li><code>CoverDigraph(P)</code> returns a directed graph whose vertices are the elements of <code>P</code> in which <code>(x,y)</code> is an edges provided both <code>x&lt;y</code> in <code>P</code> and there is no <code>z</code> for which <code>x&lt;z&lt;y</code>. These are the edges that would appear in a Hasse diagram of <code>P</code>.</li><li><code>mobius(P)</code> creates the Mobius function for this poset (as a dictionary from pairs of elements to <code>Int</code> values).</li><li><code>mobius_matrix(P)</code> is the inverse of <code>zeta_matrix(P)</code>.</li><li><code>zeta(P)</code> creates the zeta function for this poset (as a dictionary from pairs of elements to <code>Int</code> values). We have <code>(x,y) ==&gt; 1</code> provided <code>x==y</code> or <code>x&lt;y</code>, and <code>(x,y) ==&gt; 0</code> otherwise.</li><li><code>zeta_matrix(P)</code> produces the zeta matrix. Order of elements is the same as produced by <code>elements(P)</code>.</li><li><code>height(P)</code> returns the maximum size of a chain.</li></ul><h2><a class="nav-anchor" id="Linear-extensions-1" href="#Linear-extensions-1">Linear extensions</a></h2><ul><li><code>linear_extension(P)</code> finds one linear extension of the poset (as an <code>Array</code>).</li><li><code>random_linear_extension(P)</code> returns a random linear extension. See the  help message for more detail.</li><li><code>all_linear_extensions(P)</code> returns a <code>Set</code> containing all the linear extensions of the poset. This is a <em>very</em> expensive operation in both time and memory. It is memoized to make it more efficient, but the memory it uses is <em>not</em> freed after use.</li></ul><p>```julia julia&gt; P = Divisors(12) SimplePoset{Int64} (6 elements)</p><p>julia&gt; linear_extension(P)&#39; 1×6 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:  1  2  3  4  6  12</p><p>julia&gt; random<em>linear</em>extension(P)&#39; 1×6 LinearAlgebra.Adjoint{Int64,Array{Int64,1}}:  1  3  2  6  4  12</p><p>julia&gt; collect(all<em>linear</em>extensions(P)) 5-element Array{Array{Int64,1},1}:  [1, 3, 2, 4, 6, 12]  [1, 3, 2, 6, 4, 12]  [1, 2, 3, 6, 4, 12]  [1, 2, 3, 4, 6, 12]  [1, 2, 4, 3, 6, 12]   ```</p><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><h3><a class="nav-anchor" id="Under-the-hood-1" href="#Under-the-hood-1">Under the hood</a></h3><p>A <code>SimplePoset</code> is a wrapper around a <code>SimpleDigraph</code> object. The functions for creating and manipulating a <code>SimplePoset</code> ensure that the underlying digraph has directed edges <code>(x,y)</code> exactly for those pairs of elements with <code>x&lt;y</code>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
