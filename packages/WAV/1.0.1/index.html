<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Readme · WAV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>WAV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Readme</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#wavread-1">wavread</a></li><li><a class="toctext" href="#wavwrite-1">wavwrite</a></li><li><a class="toctext" href="#wavappend-1">wavappend</a></li><li><a class="toctext" href="#wavplay-1">wavplay</a></li><li><a class="toctext" href="#WAVChunk-1">WAVChunk</a></li><li><a class="toctext" href="#Other-Julia-Audio-Packages-1">Other Julia Audio Packages</a></li></ul></li><li><a class="toctext" href="autodocs/">Docstrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Readme</a></li></ul></nav><hr/><div id="topbar"><span>Readme</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="WAV.jl-1" href="#WAV.jl-1">WAV.jl</a></h1><p><a href="http://pkg.julialang.org/?pkg=WAV&amp;ver=1.0"><img src="http://pkg.julialang.org/badges/WAV_1.0.svg" alt="WAV"/></a> <a href="https://travis-ci.org/dancasimiro/WAV.jl"><img src="https://travis-ci.org/dancasimiro/WAV.jl.png" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/dancasimiro/wav-jl"><img src="https://ci.appveyor.com/api/projects/status/github/dancasimiro/wav.jl?branch=master&amp;svg=true" alt="Windows Build Status"/></a> <a href="https://coveralls.io/r/dancasimiro/WAV.jl"><img src="https://coveralls.io/repos/dancasimiro/WAV.jl/badge.png" alt="Coverage Status"/></a></p><p>This is a Julia package to read and write the WAV audio file format.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><pre><code class="language-none">julia&gt; Pkg.add(&quot;WAV&quot;)</code></pre><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>WAV provides <code>wavread</code>, <code>wavwrite</code>, and <code>wavappend</code> commands to read, write, and append WAV files. Here is an example to get you started. It generates some data, writes it to a file and then reads the data back. <code>wavplay</code> is also provided for simple audio playback.</p><pre><code class="language-jlcon">julia&gt; using WAV
julia&gt; x = [0:7999;]
julia&gt; y = sin.(2 * pi * x / 8000)
julia&gt; wavwrite(y, &quot;example.wav&quot;, Fs=8000)
julia&gt; y, fs = wavread(&quot;example.wav&quot;)
julia&gt; y = cos.(2 * pi * x / 8000)
julia&gt; wavappend(y, &quot;example.wav&quot;)
julia&gt; y, fs = wavread(&quot;example.wav&quot;)
julia&gt; wavplay(y, fs)</code></pre><h2><a class="nav-anchor" id="wavread-1" href="#wavread-1">wavread</a></h2><p>This function reads the samples from a WAV file. The samples are converted to floating point values in the range from -1.0 to 1.0 by default.</p><pre><code class="language-julia">function wavread(io::IO; subrange=Any, format=&quot;double&quot;)
function wavread(filename::String; subrange=Any, format=&quot;double&quot;)</code></pre><p>The available options, and the default values, are:</p><ul><li><span>$format$</span> (default = <span>$double$</span>): changes the format of the returned samples. The string <span>$double$</span> returns double precision floating point values in the range -1.0 to 1.0. The string <span>$native$</span> returns the values as encoded in the file. The string <span>$size$</span> returns the number of samples in the file, rather than the actual samples.</li><li><span>$subrange$</span> (default = <span>$Any$</span>): controls which samples are returned. The default, <span>$Any$</span> returns all of the samples. Passing a number (<span>$Real$</span>), <span>$N$</span>, will return the first <span>$N$</span> samples of each channel. Passing a range (<span>$Range1{Real}$</span>), <span>$R$</span>, will return the samples in that range of each channel.</li></ul><p>The returned values are:</p><ul><li><span>$y$</span>: The acoustic samples; A matrix is returned for files that contain multiple channels.</li><li><span>$Fs$</span>: The sampling frequency</li><li><span>$nbits$</span>: The number of bits used to encode each sample</li><li><span>$opt$</span>: A vector of <code>WAVChunk</code> of optional chunks found in the WAV file.</li></ul><p>The elements in the <span>$opt$</span> vector depend on the contents of the WAV file.</p><p>A <span>$WAVChunk$</span> is defined as</p><pre><code class="language-julia">mutable struct WAVChunk
    id::Symbol
    data::Vector{UInt8}
end</code></pre><p>where the ID is the four-character chunk ID. All valid WAV files will contain a <span>$fmt$</span> chunk, with ID <span>$Symbol(&quot;fmt &quot;)$</span> (note the trailing space).</p><p>In order to obtain the contents of the format chunk, call <span>$getformat(opt)$</span>. This will return an instance of type <span>$WAVFormat$</span>. The <span>$WAVFormat$</span> type is defined as:</p><pre><code class="language-julia">struct WAVFormat
    compression_code::UInt16
    nchannels::UInt16
    sample_rate::UInt32
    bytes_per_second::UInt32 # average bytes per second
    block_align::UInt16
    nbits::UInt16
    ext::WAVFormatExtension
end</code></pre><p>The <code>ext</code> field of type <code>WAVFormatExtension</code> is defined as:</p><pre><code class="language-julia">struct WAVFormatExtension
    nbits::UInt16 # overrides nbits in WAVFormat type
    channel_mask::UInt32
    sub_format::Array{UInt8, 1} # 16 byte GUID
    WAVFormatExtension() = new(0, 0, Array(UInt8, 0))
    WAVFormatExtension(nb, cm, sb) = new(nb, cm, sb)
end</code></pre><p>You can use the <code>isformat</code> function to test how the samples are encoded, without worrying about the <code>WAVFormatExtension</code> type. Extended WAV files were added to deal with some ambiguity in the original specification.</p><pre><code class="language-julia">isformat(fmt::WAVFormat, code)</code></pre><p>The <code>isformat</code> function takes the <span>$WAVFormat$</span> object returned by <span>$getformat$</span> and one of <code>WAV_FORMAT_</code> constants, respectively. The function returns <code>true</code> when the samples are encoded in the specified <code>code</code>.</p><p>The following functions are also defined to make this function compatible with MATLAB:</p><pre><code class="language-julia">wavread(filename::String, fmt::String) = wavread(filename, format=fmt)
wavread(filename::String, N::Int) = wavread(filename, subrange=N)
wavread(filename::String, N::Range1{Int}) = wavread(filename, subrange=N)
wavread(filename::String, N::Int, fmt::String) = wavread(filename, subrange=N, format=fmt)
wavread(filename::String, N::Range1{Int}, fmt::String) = wavread(filename, subrange=N, format=fmt)</code></pre><h2><a class="nav-anchor" id="wavwrite-1" href="#wavwrite-1">wavwrite</a></h2><p>Writes samples to a RIFF/WAVE file io object. The <span>$io$</span> argument accepts either an <span>$IO$</span> object or a filename (<span>$String$</span>). The function assumes that the sample rate is 8 kHz and uses 16 bits to encode each sample. Both of these values can be changed with the options parameter. Each column of the data represents a different channel. Stereo files should contain two columns. The options are passed via an <span>$Options$</span> object (see the :ref:<code>options page &lt;options-module&gt;</code>).</p><pre><code class="language-julia">function wavwrite(samples::Array, io::IO; Fs=8000, nbits=16, compression=WAVE_FORMAT_PCM, chunks::Vector{WAVChunk}=WAVChunk[])
function wavwrite(samples::Array, filename::String; Fs=8000, nbits=16, compression=WAVE_FORMAT_PCM, chunks::Vector{WAVChunk}=WAVChunk[])</code></pre><p>The available options, and the default values, are:</p><ul><li><span>$Fs$</span> (default = <span>$8000$</span>): sampling frequency</li><li><span>$nbits$</span> (default = <span>$16$</span>): number of bits used to encode each sample</li><li><span>$compression$</span> (default = <span>$WAV_FORMAT_PCM$</span>): controls the type of encoding used in the file</li><li><span>$chunks$</span> (default = <span>$WAVChunk[]$</span>): a vector of <span>$WAVChunk$</span> objects to be written to the file (in addition to the format chunk). See below for some utilities for creating <span>$CUE$</span> and <span>$INFO$</span></li></ul><p>chunks.</p><p>The type of the input array, samples, also affects the generated file. &quot;Native&quot; WAVE files are written when integers are passed into wavwrite. This means that the literal values are written into the file. The input ranges are as follows for integer samples.</p><table><tr><th>N Bits</th><th>y Data Type</th><th>y Data Range</th><th>Output Format</th></tr><tr><td>8</td><td>uint8</td><td>0 &lt;= y &lt;= 255</td><td>uint8</td></tr><tr><td>16</td><td>int16</td><td>–32768 &lt;= y &lt;= +32767</td><td>int16</td></tr><tr><td>24</td><td>int32</td><td>–2^23 &lt;= y &lt;= 2^23 – 1</td><td>int32</td></tr></table><p>If samples contains floating point values, the input data ranges are the following.</p><table><tr><th>N Bits</th><th>y Data Type</th><th>y Data Range</th><th>Output Format</th></tr><tr><td>8</td><td>single or double</td><td>–1.0 &lt;= y &lt; +1.0</td><td>uint8</td></tr><tr><td>16</td><td>single or double</td><td>–1.0 &lt;= y &lt; +1.0</td><td>int16</td></tr><tr><td>24</td><td>single or double</td><td>–1.0 &lt;= y &lt; +1.0</td><td>int32</td></tr><tr><td>32</td><td>single or double</td><td>–1.0 &lt;= y &lt;= +1.0</td><td>single</td></tr></table><p>Floating point (single and double precision) values are written to the file unaltered. The library will not modify the data range or representation.</p><p>The following functions are also defined to make this function compatible with MATLAB:</p><pre><code class="language-julia">wavwrite(y::Array, f::Real, filename::String) = wavwrite(y, filename, Fs=f)
wavwrite(y::Array, f::Real, N::Real, filename::String) = wavwrite(y, filename, Fs=f, nbits=N)
wavwrite(y::Array{T}, io::IO) where {T&lt;:Integer} = wavwrite(y, io, nbits=sizeof(T)*8)
wavwrite(y::Array{T}, filename::String) where {T&lt;:Integer} = wavwrite(y, filename, nbits=sizeof(T)*8)
wavwrite(y::Array{Int32}, io::IO) = wavwrite(y, io, nbits=24)
wavwrite(y::Array{Int32}, filename::String) = wavwrite(y, filename, nbits=24)
wavwrite(y::Array{T}, io::IO) where {T&lt;:FloatingPoint} = wavwrite(y, io, nbits=sizeof(T)*8, compression=WAVE_FORMAT_IEEE_FLOAT)
wavwrite(y::Array{T}, filename::String) where {T&lt;:FloatingPoint} = wavwrite(y, filename, nbits=sizeof(T)*8, compression=WAVE_FORMAT_IEEE_FLOAT)</code></pre><h2><a class="nav-anchor" id="wavappend-1" href="#wavappend-1">wavappend</a></h2><p>Append samples to an existing WAV file.  All parameters (data type and range, output format, number of bits, number of channels, etc.) are assumed to match.</p><pre><code class="language-julia">function wavappend(samples::Array, io::IO)
function wavappend(samples::Array, filename::String)</code></pre><h2><a class="nav-anchor" id="wavplay-1" href="#wavplay-1">wavplay</a></h2><p>Playing audio back is also supported. The supported backends are: AudioQueue (MacOSX) and Pulse Audio (Linux, libpulse-simple). There is not a native backend for Windows yet.</p><pre><code class="language-julia">function wavplay(samples::Array, fs::Number)</code></pre><h2><a class="nav-anchor" id="WAVChunk-1" href="#WAVChunk-1">WAVChunk</a></h2><p>Experimental support for reading and writing <span>$CUE$</span> and <span>$INFO$</span> chunks has been added in version 1. The function</p><pre><code class="language-julia">wav_cue_read(chunks::Vector{WAVChunk})</code></pre><p>takes a <span>$Vector{WAVChunk}$</span> (as returned by <span>$wavread$</span>) and returns a <span>$Vector{WAVMarker}$</span>, where a <span>$WAVMarker$</span> is defined as:</p><pre><code class="language-julia">mutable struct WAVMarker
    label::String
    start_time::UInt32
    duration::UInt32
end</code></pre><p>Where <span>$start_time$</span> and <span>$duration$</span> are in samples. You can also turn <span>$WAVMarker$</span>s into a <span>$Vector{WAVChunk}$</span> (as accepted by <span>$wavwrite$</span>) by calling</p><pre><code class="language-julia">wav_cue_write(markers::Dict{UInt32, WAVMarker})</code></pre><p>where the key for the dictionary is the ID of the marker to be written to file.</p><p>Similar functions exist for <span>$INFO$</span> chunks, namely</p><pre><code class="language-julia">wav_info_write(tags::Dict{Symbol, String})::Vector{WAVChunk}
wav_info_read(chunks::Vector{WAVChunk})::Dict{Symbol, String}</code></pre><p>where the keys for the <span>$Dict{Symbol, String}$</span> should be four-character RIFF INFO tag IDs as specified <a href="https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html#Info">here</a>. The values of the dictionary correspond to the tag data.</p><h2><a class="nav-anchor" id="Other-Julia-Audio-Packages-1" href="#Other-Julia-Audio-Packages-1">Other Julia Audio Packages</a></h2><p><a href="https://github.com/ssfrr/AudioIO.jl">AudioIO</a> is another audio library in the Julia ecosystem. It supports more file formats (including WAV) and implements a more powerful playback interface. However, the license is more restrictive (GPL) because of a dependence on <a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a>.</p><p>Additionally, <a href="https://github.com/dmbates/FLAC.jl">FLAC.jl</a> includes an <code>mmap</code> based WAV <a href="https://github.com/dmbates/FLAC.jl/blob/master/src/WAV.jl">reader</a>.</p><footer><hr/><a class="next" href="autodocs/"><span class="direction">Next</span><span class="title">Docstrings</span></a></footer></article></body></html>
